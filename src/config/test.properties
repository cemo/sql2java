#
# SAMPLE PROPERTIES FILE FOR SQL2JAVA 
#


#----------------------------------------------
# (1/7) CONFIGURE YOUR DATABASE ACCESS
#----------------------------------------------
#jdbc.driver=org.hsqldb.jdbcDriver
#jdbc.url=jdbc:hsqldb:hsql://localhost
#jdbc.username=sa
#jdbc.password=
#jdbc.schema=

jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/schema_here
jdbc.username=
jdbc.password=
jdbc.schema=schema_here


#-------------------------------------------------
# (2/7) CONFIGURE RETRIEVAL OF AUTO GENERATED KEY
#-------------------------------------------------
# For those who do not want to read below, please simply pick up the
# configuration associated with your database.
#
# More explanation:
# When you save a bean whose primary key is numeric and has no value set,
# we assume that you want sql2java to retrieve a key's value generated 
# on the database side.
#
# generatedkey.retrieve can take 4 values:
#
# auto - the standard approach when you have a JDBC 3.0 driver.
#
# before - the key's value is retrieved before inserting the record.
#
# after - the key's value is retrieved after inserting the record
#
# none - the key's value is never retrieved, frankly I doubt you 
#        want this configuration
#
# If you set it to before or after you also need to configure the
# autogeneratedkey.statement properties. 
# <TABLE> is replaced at code generation time by the table name. 
# You may adjust this properties to fit your own naming convention.
#
# PICK THE CONFIGURATION ASSOCIATED WITH YOUR DATABASE
# (or create one, but in that case let us know so we can add it here... :-)
#
#-- HSQL ------
#generatedkey.retrieve=after
#generatedkey.statement=CALL IDENTITY()
#
#-- IF YOU USE A JDBC 3.0 DRIVER (works with mysql, ORACLE 9, etc..) ------
generatedkey.retrieve=auto
generatedkey.statement=
#
#-- MYSQL (without jdbc 3.0 driver) ------
#generatedkey.retrieve=after
#generatedkey.statement=SELECT last_insert_id()
#
#-- POSTGRESQL ------
#generatedkey.retrieve=before
#generatedkey.statement=SELECT nextval('<TABLE>_SEQ')
#


#----------------------------------------------
# (3/7) GENERATED SOURCE CODE
#----------------------------------------------

# Package name for the generated source code
mgrwriter.package=net.sql2java.sample.database

# Destination of the generated source code (package hierarchy is preserved)
mgrwriter.destdir=target/generated-sources

# Property file to use when initializing Velocity
#mgrwriter.velocityprops=somefile

# templates (you can generate java files, jsp, etc...)

mgrwriter.templates.loadingpath=target/classes/templates/velocity/global, \
                                target/classes/templates/velocity/table, \
                                target/classes/templates/velocity/includes

mgrwriter.templates.perschema=  daomanager.java.vm, \
                                basemanager.java.vm, \
                                cachingmanager.java.vm
        
mgrwriter.templates.pertable=   bean.java.vm, \
                                manager.java.vm 

# sets a prefix to prepend to all generated classes
# useful if you are worried about namespace collision with reserved words
# or java.lang classes
#mgrwriter.classprefix=


#-----------------------------------------------
# (4/7) JDBC TYPES Mapping
#-----------------------------------------------
# 
# jdbc DATE mapping can be:
#  java.sql.Date
#  java.util.Date
jdbc2java.date=java.util.Date

# jdbc TIME mapping can be:
#  java.sql.Time
#  java.util.Date
jdbc2java.time=java.util.Date

# jdbc TIMESTAMP mappning can be:
#  java.sql.Timestamp
#  java.util.Date
jdbc2java.timestamp=java.util.Date


#-----------------------------------------------
# (5/7) FILTER OUT CERTAIN TABLES
#-----------------------------------------------
#
# COMMA SEPARATED list of table types to be mapped
# Commonly seen types are TABLE, VIEW, SYSTEM TABLE, SYNONYM
jdbc.tabletypes=TABLE

# Table name pattern of tables to be mapped to classes.
# available wildcard: %
# defaults to %
# You can specify several patterns separated by commas.
jdbc.tablenamepattern=%

# SPACE SEPARATED list of tables to include or exclude.  If you specify both,
# the include list will take priority. If these fields are left commented out,
# all tables in the specified schema will get mapped to classes
#mgrwriter.include=Testing
#mgrwriter.exclude=


#-----------------------------------------------
# (6/7) CONFIGURE OPTIMISTIC LOCK
#-----------------------------------------------
# optimisticlock.type can take 2 values:
# none - the optimistic lock mechanism is disabled (default).
# timestamp - the optimistic lock column contains the System.currentTimeMillis() value.
#
# optimisticlock.column takes the column name used by optimistic lock mechanism in your database.
# If this column is not present in some table the optimistic lock is not applied there.
# the column mapping can be java.lang.Long or java.lang.String.
# (jdbc type size >= 13 characters)
optimisticlock.type=timestamp
optimisticlock.column=version_time


#-----------------------------------------------
# (7/7) ORGANISE YOUR SUBPACKAGES
#-----------------------------------------------
#subpackage.1.name=products.delivery
#subpackage.1.tables=delivery

#subpackage.2.name=products.product
#subpackage.2.tables=product

#subpackage.3.name=products.manufacturer
#subpackage.3.tables=manufacturer

#subpackage.4.name=users
#subpackage.4.tables=customer, shipper,


